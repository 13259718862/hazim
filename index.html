<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CartPole Policy Gradient Sandbox</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f172a;
      --card: #111827;
      --accent: #22c55e;
      --muted: #cbd5e1;
      --grid: #1f2937;
    }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, #0b1224, #070b14 40%),
        radial-gradient(circle at 80% 0%, #0b132b, transparent 35%), var(--bg);
      color: #e2e8f0;
    }
    header {
      padding: 24px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    h1 {
      margin: 0;
      font-weight: 800;
      letter-spacing: -0.02em;
    }
    .badge {
      padding: 4px 10px;
      background: #1d4ed8;
      border-radius: 999px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #cbd5ff;
    }
    main {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
      padding: 0 24px 24px;
    }
    .card {
      background: linear-gradient(145deg, #0c1221, #0a0f1b);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 14px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
      padding: 16px;
    }
    .card h2 {
      margin: 0 0 12px;
      font-size: 16px;
      letter-spacing: 0.01em;
    }
    #envCanvas {
      width: 100%;
      height: 360px;
      background: #0b1020;
      border: 1px solid #1f2937;
      border-radius: 10px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
    }
    button {
      border: none;
      background: #1e293b;
      color: #e2e8f0;
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }
    button.primary {
      background: linear-gradient(120deg, #0ea5e9, #22c55e);
      color: #0b1221;
    }
    button.secondary {
      background: #334155;
    }
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 8px;
    }
    .metric {
      padding: 10px;
      border-radius: 10px;
      background: #0f162b;
      border: 1px solid #1f2937;
    }
    .metric .label {
      font-size: 12px;
      color: #94a3b8;
    }
    .metric .value {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    #chartCanvas {
      width: 100%;
      height: 180px;
      background: #0b1020;
      border-radius: 10px;
      border: 1px solid #1f2937;
    }
    .grid {
      display: grid;
      gap: 12px;
    }
    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }
    .chip {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      background: #111827;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      font-size: 12px;
    }
    .bars {
      display: flex;
      gap: 4px;
      align-items: flex-end;
      height: 60px;
    }
    .bar {
      flex: 1;
      border-radius: 4px 4px 0 0;
      background: linear-gradient(180deg, #22c55e, #0ea5e9);
    }
    svg {
      width: 100%;
      height: 240px;
      background: #0b1020;
      border-radius: 10px;
      border: 1px solid #1f2937;
    }
    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 12px;
      color: #94a3b8;
    }
    .legend span {
      display: inline-block;
      width: 14px;
      height: 6px;
      border-radius: 999px;
    }
    .pill {
      background: #0b1224;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      font-size: 12px;
      color: #cbd5e1;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .pill label {
      color: #94a3b8;
      font-weight: 600;
    }
    .pill input[type='range'] {
      accent-color: #22c55e;
      width: 140px;
    }
    .pill input[type='number'] {
      background: #0f172a;
      border: 1px solid #1f2937;
      border-radius: 6px;
      color: #e2e8f0;
      padding: 4px 6px;
      width: 70px;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <div class="badge">CartPole • Policy Gradient</div>
      <h1>Interactive CartPole RL Sandbox</h1>
      <p style="margin:4px 0 0;color:#94a3b8">Train a lightweight policy-gradient controller directly in your browser.</p>
    </div>
    <div class="chip">
      <span style="width:10px;height:10px;border-radius:50%;background:#22c55e;"></span>
      <span id="status">Idle</span>
    </div>
  </header>
  <main>
    <section class="card">
      <div class="controls">
        <button id="trainBtn" class="primary">Start Training</button>
        <button id="stepBtn" class="secondary">Step Episode</button>
        <button id="resetBtn" class="secondary">Reset</button>
        <span class="pill">
          <label for="lrInput">Learning rate</label>
          <input id="lrInput" type="range" min="0.001" max="0.1" step="0.001" value="0.02" />
          <input id="lrNumber" type="number" min="0.001" max="0.1" step="0.001" value="0.02" />
          <span id="lrVal">0.02</span>
        </span>
        <span class="pill">
          <label for="gammaInput">Gamma</label>
          <input id="gammaInput" type="range" min="0.8" max="0.999" step="0.001" value="0.99" />
          <input id="gammaNumber" type="number" min="0.8" max="0.999" step="0.001" value="0.99" />
          <span id="gammaVal">0.99</span>
        </span>
      </div>
      <canvas id="envCanvas" width="800" height="360"></canvas>
      <div class="metrics" style="margin-top:10px;">
        <div class="metric">
          <div class="label">Episode</div>
          <div class="value" id="epCount">0</div>
        </div>
        <div class="metric">
          <div class="label">Steps this episode</div>
          <div class="value" id="stepCount">0</div>
        </div>
        <div class="metric">
          <div class="label">Reward this episode</div>
          <div class="value" id="rewardVal">0.0</div>
        </div>
        <div class="metric">
          <div class="label">Last survival</div>
          <div class="value" id="lastSurvival">0 steps</div>
        </div>
        <div class="metric">
          <div class="label">Best survival</div>
          <div class="value" id="bestSurvival">0 steps</div>
        </div>
      </div>
    </section>
    <section class="grid card">
      <div>
        <h2>Episode Metrics</h2>
        <canvas id="chartCanvas" width="500" height="180"></canvas>
      </div>
      <div>
        <h2>Policy Network</h2>
        <svg id="networkSvg"></svg>
        <div class="legend">
          <span style="background:#ef4444"></span> Positive weight
          <span style="background:#3b82f6"></span> Negative weight
        </div>
      </div>
      <div>
        <h2>Hidden Activations</h2>
        <div id="activationBars" class="bars"></div>
      </div>
      <div>
        <h2>Weight Snapshot</h2>
        <div id="weightSnapshot" style="font-family:monospace;font-size:12px;line-height:1.4"></div>
      </div>
    </section>
  </main>
  <script>
    // --- Utility helpers --------------------------------------------------
    const rand = (a, b) => Math.random() * (b - a) + a;
    const clamp = (x, min, max) => Math.min(Math.max(x, min), max);
    const sigmoid = (x) => 1 / (1 + Math.exp(-x));

    // --- CartPole environment --------------------------------------------
    class CartPole {
      constructor() {
        this.gravity = 9.8;
        this.massCart = 1.0;
        this.massPole = 0.1;
        this.totalMass = this.massCart + this.massPole;
        this.length = 0.5; // actually half the pole's length
        this.polemassLength = this.massPole * this.length;
        this.forceMag = 10.0;
        this.tau = 0.02;
        this.thetaThreshold = (12 * Math.PI) / 180;
        this.xThreshold = 2.4;
        this.reset();
      }
      reset() {
        this.x = rand(-0.05, 0.05);
        this.xDot = rand(-0.05, 0.05);
        this.theta = rand(-0.05, 0.05);
        this.thetaDot = rand(-0.05, 0.05);
        this.steps = 0;
        return this.state();
      }
      state() {
        return [this.x, this.xDot, this.theta, this.thetaDot];
      }
      step(action) {
        const force = action === 1 ? this.forceMag : -this.forceMag;
        const cos = Math.cos(this.theta);
        const sin = Math.sin(this.theta);
        const temp = (force + this.polemassLength * this.thetaDot * this.thetaDot * sin) / this.totalMass;
        const thetaAcc = (this.gravity * sin - cos * temp) /
          (this.length * (4.0 / 3.0 - (this.massPole * cos * cos) / this.totalMass));
        const xAcc = temp - (this.polemassLength * thetaAcc * cos) / this.totalMass;

        this.x += this.tau * this.xDot;
        this.xDot += this.tau * xAcc;
        this.theta += this.tau * this.thetaDot;
        this.thetaDot += this.tau * thetaAcc;
        this.steps += 1;

        const done =
          this.x < -this.xThreshold ||
          this.x > this.xThreshold ||
          this.theta < -this.thetaThreshold ||
          this.theta > this.thetaThreshold;
        return { state: this.state(), reward: done ? 0 : 1, done };
      }
    }

    // --- Policy network (single hidden layer) ----------------------------
    class PolicyNetwork {
      constructor(input = 4, hidden = 8) {
        this.input = input;
        this.hidden = hidden;
        this.W1 = Array.from({ length: input }, () => Array.from({ length: hidden }, () => rand(-0.2, 0.2)));
        this.b1 = Array.from({ length: hidden }, () => 0);
        this.W2 = Array.from({ length: hidden }, () => rand(-0.2, 0.2));
        this.b2 = 0;
        this.activations = Array(hidden).fill(0);
      }
      forward(state) {
        const h = Array(this.hidden).fill(0);
        for (let j = 0; j < this.hidden; j++) {
          let sum = this.b1[j];
          for (let i = 0; i < this.input; i++) sum += this.W1[i][j] * state[i];
          h[j] = Math.tanh(sum);
        }
        this.activations = h;
        let logit = this.b2;
        for (let j = 0; j < this.hidden; j++) logit += this.W2[j] * h[j];
        const prob = sigmoid(logit);
        return { prob, hidden: h, logit };
      }
      sample(state) {
        const { prob, hidden } = this.forward(state);
        return { action: Math.random() < prob ? 1 : 0, prob, hidden };
      }
      update(trajectory, lr = 0.02, gamma = 0.99) {
        const n = trajectory.rewards.length;
        const returns = Array(n).fill(0);
        let running = 0;
        for (let t = n - 1; t >= 0; t--) {
          running = trajectory.rewards[t] + gamma * running;
          returns[t] = running;
        }
        const mean = returns.reduce((a, b) => a + b, 0) / n;
        const std = Math.sqrt(returns.reduce((a, b) => a + (b - mean) ** 2, 0) / n) || 1;

        const gradW1 = Array.from({ length: this.input }, () => Array(this.hidden).fill(0));
        const gradb1 = Array(this.hidden).fill(0);
        const gradW2 = Array(this.hidden).fill(0);
        let gradb2 = 0;

        for (let t = 0; t < n; t++) {
          const adv = (returns[t] - mean) / std;
          const prob = trajectory.probs[t];
          const action = trajectory.actions[t];
          const hidden = trajectory.hiddens[t];
          const error = (action - prob) * adv; // gradient of log pi

          for (let j = 0; j < this.hidden; j++) {
            gradW2[j] += error * hidden[j];
          }
          gradb2 += error;

          for (let j = 0; j < this.hidden; j++) {
            const dHidden = error * this.W2[j] * (1 - hidden[j] * hidden[j]);
            for (let i = 0; i < this.input; i++) gradW1[i][j] += dHidden * trajectory.states[t][i];
            gradb1[j] += dHidden;
          }
        }

        const scale = lr / n;
        for (let i = 0; i < this.input; i++) {
          for (let j = 0; j < this.hidden; j++) this.W1[i][j] += scale * gradW1[i][j];
        }
        for (let j = 0; j < this.hidden; j++) {
          this.b1[j] += scale * gradb1[j];
          this.W2[j] += scale * gradW2[j];
        }
        this.b2 += scale * gradb2;
      }
    }

    // --- UI State ---------------------------------------------------------
    const env = new CartPole();
    const policy = new PolicyNetwork(4, 10);

    const envCanvas = document.getElementById('envCanvas');
    const envCtx = envCanvas.getContext('2d');
    const chartCanvas = document.getElementById('chartCanvas');
    const chartCtx = chartCanvas.getContext('2d');
    const networkSvg = document.getElementById('networkSvg');
    const activationBars = document.getElementById('activationBars');
    const weightSnapshot = document.getElementById('weightSnapshot');

    const statusEl = document.getElementById('status');
    const epCountEl = document.getElementById('epCount');
    const stepCountEl = document.getElementById('stepCount');
    const rewardValEl = document.getElementById('rewardVal');
    const lastSurvivalEl = document.getElementById('lastSurvival');
    const bestSurvivalEl = document.getElementById('bestSurvival');
    const lrValEl = document.getElementById('lrVal');
    const gammaValEl = document.getElementById('gammaVal');
    const lrInput = document.getElementById('lrInput');
    const lrNumber = document.getElementById('lrNumber');
    const gammaInput = document.getElementById('gammaInput');
    const gammaNumber = document.getElementById('gammaNumber');

    let training = false;
    let episode = 0;
    let bestSurvival = 0;
    const history = [];

    function bindHyperparamControls() {
      const bindPair = (rangeEl, numberEl, displayEl) => {
        const updateDisplay = (value) => {
          displayEl.textContent = parseFloat(value).toFixed(3);
        };
        const updateFromRange = () => {
          numberEl.value = rangeEl.value;
          updateDisplay(rangeEl.value);
        };
        const updateFromNumber = () => {
          const val = clamp(
            parseFloat(numberEl.value) || parseFloat(rangeEl.min),
            parseFloat(rangeEl.min),
            parseFloat(rangeEl.max)
          );
          rangeEl.value = val;
          numberEl.value = val;
          updateDisplay(val);
        };
        rangeEl.addEventListener('input', updateFromRange);
        numberEl.addEventListener('input', updateFromNumber);
        updateFromRange();
      };

      bindPair(lrInput, lrNumber, lrValEl);
      bindPair(gammaInput, gammaNumber, gammaValEl);
    }

    function getHyperparams() {
      return {
        lr: parseFloat(lrInput.value),
        gamma: parseFloat(gammaInput.value)
      };
    }

    function drawEnv() {
      envCtx.clearRect(0, 0, envCanvas.width, envCanvas.height);
      envCtx.fillStyle = '#0b1020';
      envCtx.fillRect(0, 0, envCanvas.width, envCanvas.height);
      envCtx.strokeStyle = '#1f2937';
      envCtx.lineWidth = 1;
      for (let x = 0; x < envCanvas.width; x += 40) {
        envCtx.beginPath();
        envCtx.moveTo(x + 0.5, 0);
        envCtx.lineTo(x + 0.5, envCanvas.height);
        envCtx.stroke();
      }
      envCtx.fillStyle = '#22c55e';
      envCtx.fillRect(0, envCanvas.height - 30, envCanvas.width, 30);

      const cartY = envCanvas.height - 60;
      const scale = envCanvas.width / (env.xThreshold * 2 + 0.4);
      const cartX = envCanvas.width / 2 + env.x * scale;
      envCtx.fillStyle = '#0ea5e9';
      envCtx.fillRect(cartX - 25, cartY - 15, 50, 30);

      const poleLength = 120;
      envCtx.save();
      envCtx.translate(cartX, cartY - 15);
      envCtx.rotate(env.theta);
      envCtx.fillStyle = '#f97316';
      envCtx.fillRect(-5, -poleLength, 10, poleLength);
      envCtx.beginPath();
      envCtx.arc(0, 0, 6, 0, Math.PI * 2);
      envCtx.fillStyle = '#e2e8f0';
      envCtx.fill();
      envCtx.restore();
    }

    function drawChart() {
      chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
      chartCtx.fillStyle = '#0b1020';
      chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);
      chartCtx.strokeStyle = '#1f2937';
      chartCtx.lineWidth = 1;
      for (let x = 0; x < chartCanvas.width; x += 40) {
        chartCtx.beginPath();
        chartCtx.moveTo(x + 0.5, 0);
        chartCtx.lineTo(x + 0.5, chartCanvas.height);
        chartCtx.stroke();
      }
      const maxPoints = history.length;
      if (!maxPoints) return;
      const maxReward = Math.max(...history.map((h) => h.reward));
      chartCtx.strokeStyle = '#22c55e';
      chartCtx.lineWidth = 2;
      chartCtx.beginPath();
      history.forEach((h, idx) => {
        const x = (idx / Math.max(1, maxPoints - 1)) * chartCanvas.width;
        const y = chartCanvas.height - (h.reward / Math.max(1, maxReward)) * chartCanvas.height;
        if (idx === 0) chartCtx.moveTo(x, y);
        else chartCtx.lineTo(x, y);
      });
      chartCtx.stroke();
    }

    function renderActivations() {
      activationBars.innerHTML = '';
      const maxVal = Math.max(...policy.activations.map((v) => Math.abs(v)), 0.01);
      policy.activations.forEach((val) => {
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.height = `${(Math.abs(val) / maxVal) * 100}%`;
        bar.style.background = val >= 0 ? 'linear-gradient(180deg,#22c55e,#0ea5e9)' : 'linear-gradient(180deg,#3b82f6,#0ea5e9)';
        activationBars.appendChild(bar);
      });
    }

    function renderNetwork() {
      const width = networkSvg.clientWidth || 500;
      const height = networkSvg.clientHeight || 240;
      networkSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      networkSvg.innerHTML = '';
      const margin = 40;
      const layerX = [margin, width / 2, width - margin];
      const inputs = [
        'x',
        'ẋ',
        'θ',
        'θ̇'
      ];
      const hidden = policy.hidden;

      const nodeY = (count, idx) => margin + (height - margin * 2) * (idx / Math.max(1, count - 1));
      const colorForWeight = (w) => {
        const mag = clamp(Math.abs(w) / 1.5, 0, 1);
        const c = w >= 0 ? [239, 68, 68] : [59, 130, 246];
        return `rgba(${c[0]},${c[1]},${c[2]},${0.15 + mag * 0.85})`;
      };
      const thickness = (w) => 1 + clamp(Math.abs(w), 0, 1.5) * 2;

      // Input to hidden edges
      for (let i = 0; i < inputs.length; i++) {
        for (let j = 0; j < hidden; j++) {
          const w = policy.W1[i][j];
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', layerX[0]);
          line.setAttribute('x2', layerX[1]);
          line.setAttribute('y1', nodeY(inputs.length, i));
          line.setAttribute('y2', nodeY(hidden, j));
          line.setAttribute('stroke', colorForWeight(w));
          line.setAttribute('stroke-width', thickness(w));
          networkSvg.appendChild(line);
        }
      }
      // Hidden to output
      for (let j = 0; j < hidden; j++) {
        const w = policy.W2[j];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', layerX[1]);
        line.setAttribute('x2', layerX[2]);
        line.setAttribute('y1', nodeY(hidden, j));
        line.setAttribute('y2', height / 2);
        line.setAttribute('stroke', colorForWeight(w));
        line.setAttribute('stroke-width', thickness(w));
        networkSvg.appendChild(line);
      }

      const drawNode = (x, y, label) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', 14);
        circle.setAttribute('fill', '#0f172a');
        circle.setAttribute('stroke', '#1f2937');
        g.appendChild(circle);
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y + 4);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', '#e2e8f0');
        text.setAttribute('font-size', '12');
        text.textContent = label;
        g.appendChild(text);
        networkSvg.appendChild(g);
      };

      inputs.forEach((l, i) => drawNode(layerX[0], nodeY(inputs.length, i), l));
      for (let j = 0; j < hidden; j++) drawNode(layerX[1], nodeY(hidden, j), 'h' + (j + 1));
      drawNode(layerX[2], height / 2, 'π(left)');
    }

    function renderSnapshot() {
      const lines = [];
      lines.push('W1:');
      policy.W1.forEach((row, i) => lines.push(`  in${i}: [${row.map((v) => v.toFixed(2)).join(', ')}]`));
      lines.push('W2:');
      lines.push('  ' + policy.W2.map((v) => v.toFixed(2)).join(', '));
      lines.push(`b1: [${policy.b1.map((v) => v.toFixed(2)).join(', ')}]`);
      lines.push(`b2: ${policy.b2.toFixed(3)}`);
      weightSnapshot.textContent = lines.join('\n');
    }

    function updateUI(epReward, epSteps) {
      epCountEl.textContent = episode;
      stepCountEl.textContent = epSteps;
      rewardValEl.textContent = epReward.toFixed(1);
      lastSurvivalEl.textContent = `${epSteps} steps`;
      bestSurvivalEl.textContent = `${bestSurvival} steps`;
      drawChart();
      renderActivations();
      renderNetwork();
      renderSnapshot();
      drawEnv();
    }

    function runEpisode(maxSteps = 500) {
      const trajectory = { states: [], actions: [], rewards: [], probs: [], hiddens: [] };
      let totalReward = 0;
      let steps = 0;
      let done = false;
      let state = env.state();
      while (!done && steps < maxSteps) {
        const { action, prob, hidden } = policy.sample(state);
        const { state: nextState, reward, done: terminal } = env.step(action);
        done = terminal;
        trajectory.states.push(state);
        trajectory.actions.push(action);
        trajectory.rewards.push(reward);
        trajectory.probs.push(prob);
        trajectory.hiddens.push(hidden);
        totalReward += reward;
        steps += 1;
        state = nextState;
      }
      return { trajectory, totalReward, steps };
    }

    async function trainingLoop() {
      if (!training) return;
      statusEl.textContent = 'Training';
      const { trajectory, totalReward, steps } = runEpisode();
      episode += 1;
      history.push({ ep: episode, reward: totalReward, steps });
      if (history.length > 100) history.shift();
      bestSurvival = Math.max(bestSurvival, steps);
      const { lr, gamma } = getHyperparams();
      policy.update(trajectory, lr, gamma);
      updateUI(totalReward, steps);
      await new Promise((r) => setTimeout(r, 5));
      requestAnimationFrame(trainingLoop);
    }

    function singleEpisode() {
      const { trajectory, totalReward, steps } = runEpisode();
      episode += 1;
      history.push({ ep: episode, reward: totalReward, steps });
      if (history.length > 100) history.shift();
      bestSurvival = Math.max(bestSurvival, steps);
      const { lr, gamma } = getHyperparams();
      policy.update(trajectory, lr, gamma);
      updateUI(totalReward, steps);
    }

    // --- Controls ---------------------------------------------------------
    document.getElementById('trainBtn').addEventListener('click', () => {
      training = !training;
      document.getElementById('trainBtn').textContent = training ? 'Pause Training' : 'Start Training';
      statusEl.textContent = training ? 'Training' : 'Idle';
      if (training) trainingLoop();
    });
    document.getElementById('stepBtn').addEventListener('click', () => {
      training = false;
      document.getElementById('trainBtn').textContent = 'Start Training';
      statusEl.textContent = 'Stepping';
      singleEpisode();
      statusEl.textContent = 'Idle';
    });
    document.getElementById('resetBtn').addEventListener('click', () => {
      training = false;
      episode = 0;
      history.length = 0;
      bestSurvival = 0;
      env.reset();
      document.getElementById('trainBtn').textContent = 'Start Training';
      statusEl.textContent = 'Idle';
      updateUI(0, 0);
    });

    bindHyperparamControls();

    // --- Initial draw -----------------------------------------------------
    env.reset();
    renderNetwork();
    renderActivations();
    renderSnapshot();
    drawEnv();
  </script>
</body>
</html>
